#define F_CPU 4000000

#include <stdint.h>

#include <avr/interrupt.h>
#include <avr/io.h>
#include <avr/pgmspace.h>
#include <avr/power.h>
#include <avr/sleep.h>

#include <util/delay.h>
#include <util/atomic.h>

#include <math.h>

#define NO_OP4() asm volatile("nop\n\tnop\n\tnop\n\tnop\n"::);

#define RANGE 20
#define BASE 2

#define ST_MICROSTEP0   (1<<0)
#define ST_MICROSTEP1   (1<<1)
#define ST_MICROSTEP2   (1<<2)
#define ST_RESET        (1<<3)
#define ST_SLEEP        (1<<4)
#define ST_STEP         (1<<5)
#define ST_DIR          (1<<6)
#define ST_LED          (1<<7)

#define STEPDDR         DDRD
#define STEPPORT        PORTD

class Sequence {
public:
    uint8_t status;         // status bits
    uint16_t run;           // if non zero, decrement counter and continue without timer change
    uint8_t tableIndex;     // current index in sine table
    uint8_t tableIncrement; // increment value to next sine table index
    uint8_t timeDivide;     // scale table value magnitude
    uint16_t stepCount;     // total steps for this segment
};

#define SEQUENCE_ACTIVE      (1<<0)
#define SEQUENCE_FREERUN     (1<<1) // step and continue at same interval
#define SEQUENCE_REVERSE     (1<<2)
#define SEQUENCE_DECELERATE  (1<<3)

// sine table generated by singen.cpp
const uint8_t table[] = {
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3,
    3, 3, 3, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 6, 6,
    6, 6, 7, 7, 7, 7, 8, 8, 8, 8, 9, 9, 9, 9, 10, 10,
    10, 10, 11, 11, 11, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 15,
    15, 15, 16, 16, 16, 17, 17, 17, 18, 18, 18, 19, 19, 20, 20, 20,
    21, 21, 21, 22, 22, 22, 23, 23, 24, 24, 24, 25, 25, 25, 26, 26,
    27, 27, 27, 28, 28, 29, 29, 29, 30, 30, 31, 31, 31, 32, 32, 32,
    32, 32, 32, 33, 33, 33, 34, 34, 35, 35, 35, 36, 36, 37, 37, 37,
    38, 38, 39, 39, 39, 40, 40, 40, 41, 41, 42, 42, 42, 43, 43, 43,
    44, 44, 44, 45, 45, 46, 46, 46, 47, 47, 47, 48, 48, 48, 49, 49,
    49, 50, 50, 50, 51, 51, 51, 51, 52, 52, 52, 53, 53, 53, 54, 54,
    54, 54, 55, 55, 55, 55, 56, 56, 56, 56, 57, 57, 57, 57, 58, 58,
    58, 58, 59, 59, 59, 59, 59, 60, 60, 60, 60, 60, 60, 61, 61, 61,
    61, 61, 61, 61, 62, 62, 62, 62, 62, 62, 62, 62, 63, 63, 63, 63,
    63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63
};

#define BASE_TIMER_COUNT  2

void initTimer0() {
    #ifndef TIMSK0
        #define TIMSK0 TIMSK
    #endif

    power_timer0_enable();
    TCCR0B = 0;                   // stop clock
    TCNT0 = 0;                    // reset counter
    TCCR0A = ( 1 << WGM01 );      // CTC
    TCCR0B = ( 1 << CS02 );       // 256 prescale

    OCR0A = BASE_TIMER_COUNT;     // fastest update time
    TIMSK0 |= ( 1 << OCIE0A );    // enable ISR
}

Sequence sequence;

ISR( TIMER0_COMPA_vect ) {
    uint8_t status = sequence.status;
    if (!(status & SEQUENCE_ACTIVE)) {
        OCR0A = BASE_TIMER_COUNT;
        return;
    }

    if (status & SEQUENCE_REVERSE) {
        STEPPORT |= ST_DIR;
    } else {
        STEPPORT &= (~ST_DIR);
    }

    // step motor
    STEPPORT |= ST_STEP;
    NO_OP4()
    STEPPORT &= (~ST_STEP);

    if (status & SEQUENCE_FREERUN) {
        return;
    }
    if (sequence.run > 0) {
        sequence.run--;
        return;
    }

    if (sequence.tableIndex == 0) {
        sequence.status ^= SEQUENCE_DECELERATE;
        if (sequence.status & SEQUENCE_DECELERATE) {
            sequence.status ^= SEQUENCE_REVERSE;
            sequence.run = 100;
        }
    }

    OCR0A = BASE_TIMER_COUNT + table[status & SEQUENCE_DECELERATE ?
        255-sequence.tableIndex :
        sequence.tableIndex];
    sequence.tableIndex += sequence.tableIncrement;
    sequence.stepCount++;
}

int main(int argc, char **argv) {
    STEPDDR = 0xff;
    STEPPORT = ST_RESET | ST_SLEEP | ST_MICROSTEP0 | ST_MICROSTEP1;

    sequence.status = SEQUENCE_ACTIVE;
    sequence.tableIndex = 0;
    sequence.tableIncrement = 1;

    initTimer0();

    sei();

    for (;;) {
    }
	return 0;
}

